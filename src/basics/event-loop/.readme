https://www.freecodecamp.org/news/node-js-what-when-where-why-how-ab8424886e2/

When Ryan Dahl created Node in 2009 he argued that I/O was being handled incorrectly, blocking the entire process due 
to synchronous programming.

Traditional web-serving techniques use the thread model, meaning one thread for each request. Since in an I/O operation 
the request spends most of the time waiting for it to complete, intensive I/O scenarios entail a large amount of unused resources (such as memory) 
linked to these threads. Therefore the “one thread per request” model for a server doesn’t scale well.

Dahl argued that software should be able to multi-task and proposed eliminating the time spent waiting for I/O results to come back. Instead of the thread model, 
he said the right way to handle several concurrent connections was to have a single-thread, 
an event loop and non-blocking I/Os. For example, when you make a query to a database, 
instead of waiting for the response you give it a callback so your execution can run through that statement and continue doing other things. 
When the results come back you can execute the callback.

Events and event-driven programming
Events are actions generated by the user or the system, like a click, a completed file download, or a hardware or software error.

Event-driven programming is a programming paradigm in which the flow of the program is determined by events. 
An event-driven program performs actions in response to events. When an event occurs it triggers a callback function.

Event Loop in node js is implemented using libuv library (its written in C)

node js = event driven + async io 
how async io is achieved = using libuv event loop
node js = core api's(c++) + v8 engine(c++) + libuv(c) + npm

event loop:
Node.js is similar in design to, and influenced by, systems like Ruby's Event Machine or Python's Twisted. 
Node.js takes the event model a bit further. It presents an event loop as a runtime construct instead of as a library. 
In other systems there is always a blocking call to start the event-loop. Typically behavior is defined through callbacks at the beginning of a 
script and at the end starts a server through a blocking call like EventMachine::run(). 
In Node.js there is no such start-the-event-loop call. Node.js simply enters the event loop after executing the input script. 
Node.js exits the event loop when there are no more callbacks to perform. This behavior is like browser JavaScript — the event loop is hidden 
from the user.

https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/

http://voidcanvas.com/setimmediate-vs-nexttick-vs-settimeout/

http://voidcanvas.com/nodejs-event-loop/



